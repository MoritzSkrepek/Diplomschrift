\chapter{Feinkonzept und Realisierung}

\section{Entwicklungsumgebungen}
\subsection{Visual Studio 2022}
Entwicklungsumgebung die mit dem Unreal Editor verbunden ist. Hier kann man die Custom C++
Blueprints schreiben.

\subsection{Unreal Editor}
Entwicklungsumgebung für Spiele. Hier entwickeln wir alle Blueprints, Custom C++ Blueprints,
Actors, Pawns, etc...

\subsection{Blender}
Mit Blender Modellieren wir alle in der Applikation verwendeten 3D-Objekte.

\section{Applikation}

\subsection{Blueprints}
Das Blueprint Visual Scripting-System in Unreal Engine ist ein vollständiges
Gameplay-Scripting-System, das auf dem Konzept basiert, eine knotenbasierte Schnittstelle
zu verwenden, um Gameplay-Elemente innerhalb des Unreal Editors zu erstellen.
Wie viele gängige Skriptsprachen wird sie zum Definieren objektorientierter (OO) Klassen
oder Objekte in der Engine verwendet. Wenn Sie UE4 verwenden, werden Sie häufig feststellen,
dass mit Blueprint definierte Objekte umgangssprachlich nur als „Blueprints“ bezeichnet werden.

Dieses System ist äußerst flexibel und leistungsstark, da es Designern die Möglichkeit bietet,
nahezu die gesamte Palette an Konzepten und Tools zu nutzen, die im Allgemeinen nur
Programmierern zur Verfügung stehen. Darüber hinaus ermöglicht das Blueprint-spezifische
Markup, das in der C++-Implementierung der Unreal Engine verfügbar ist, Programmierern die
Erstellung von Basissystemen, die von Designern erweitert werden können. \footcite{https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/}

\subsection{Arten von Blueprints}
\begin{itemize}
    \item Level Blueprint\\
    Ein Level-Blueprint ist ein spezieller Blueprint-Typ, der als Level-weiter globaler Ereignisgraph
    fungiert. Für jedes Level in Ihrem Projekt wird standardmäßig ein eigener Level-Blueprint erstellt,
    der im Unreal-Editor bearbeitet werden kann. Neue Level-Blueprints können jedoch nicht über die
    Editor-Oberfläche erstellt werden.
    \item Blueprint Klasse\\
    Eine Blueprint-Klasse, oft abgekürzt als Blueprint, ist ein Asset, das es Inhaltserstellern ermöglicht,
    auf einfache Weise Funktionen zu vorhandenen Gameplay-Klassen hinzuzufügen. Blaupausen werden visuell
    im Unreal Editor erstellt, anstatt Code einzugeben, und als Assets in einem Inhaltspaket gespeichert.
    Diese definieren im Wesentlichen eine neue Klasse oder einen neuen Akteurtyp, der dann als Instanzen in
    Karten platziert werden kann, die sich wie jeder andere Akteurtyp verhalten.
    \item Data Only Blueprint\\
    Ein Nur-Daten-Blueprint ist eine Blueprint-Klasse, die nur den Code (in Form von Knotendiagrammen),
    Variablen und Komponenten enthält, die von ihrer übergeordneten Klasse geerbt wurden. Dadurch können
    diese geerbten Eigenschaften optimiert und geändert werden, es können jedoch keine neuen Elemente hinzugefügt
    werden. Diese sind im Wesentlichen ein Ersatz für Archetypen und können verwendet werden, um Designern die
    Möglichkeit zu geben, Eigenschaften zu optimieren oder Elemente mit Variationen festzulegen.
    \item Blueprint Interface\\
    Eine Blueprint-Schnittstelle ist eine Sammlung einer oder mehrerer Funktionen – nur Namen, keine Implementierung –
    die zu anderen Blueprints hinzugefügt werden können. Jeder Blueprint, dem die Schnittstelle hinzugefügt wurde,
    verfügt garantiert über diese Funktionen. Die Funktionen der Schnittstelle können in jedem der Blueprints,
    die sie hinzugefügt haben, mit Funktionalität versehen werden. Dies ähnelt im Wesentlichen dem Konzept einer
    Schnittstelle in der allgemeinen Programmierung, das die gemeinsame Nutzung und den Zugriff mehrerer unterschiedlicher
    Objekttypen über eine gemeinsame Schnittstelle ermöglicht. Vereinfacht gesagt ermöglichen Blueprint-Schnittstellen
    die gemeinsame Nutzung und das Senden von Daten verschiedener Blueprints untereinander.
    \item Blueprint Macro Library\\
    Eine Blueprint-Makrobibliothek ist ein Container, der eine Sammlung von Makros oder eigenständigen Diagrammen enthält,
    die als Knoten in anderen Blueprints platziert werden können. Dies kann zeitsparend sein, da sie häufig verwendete
    Knotensequenzen mit Ein- und Ausgängen für die Ausführung und Datenübertragung speichern können. \footcite{https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Types/}
\end{itemize}

\subsection{Blueprint Klassen}
In Unreal Engine gibt es mehrere verschiedene Blueprint Klassen die jeweils für unterschiedliche
Konzepte verwendet werden. Darunter gibt es folgende Blueprint Klassen:
\begin{itemize}
    \item Actor \\
    Ein Objekt, dass in der Augmented Reality Welt platziert werden kann und mit
    dem interagiert werden kann
    \item Pawn \\
    Ist ein Actor, der den Spieler repräsentiert und über einen Controller (z.B.: HoloLens2)
    Spieler Input erkennen kann
    \item Player Controller \\
    Der Player Controller ist ein Actor, der dafür verantworlich ist, dass der
    Pawn, der vom Spieler verwendet wird kontrolliert wird und richtig funktioniert
    \item Game Mode \\
    Definiert das gespielte, die Regeln, Punkte und andere Aspekte des Spieltyps
\end{itemize}
Diese genannten Blueprint Klassen versichern das einfache Blueprint-Scripting, damit eine erfolgreiche
entwicklung einer Unreal Engine Applikation möglich ist. \footcite{https://docs.unrealengine.com/4.27/en-US/ProgrammingAndScripting/Blueprints/UserGuide/Types/}

\subsection{Selbstgeschriebene C++ Blueprints}
Selbst geschriebener Code kann durch Unreal Engine Tools in einen Blueprint verwandelt werden.
Dieser Blueprint kann dann wie ein normaler Blueprint im Event Graphen verwendet werden.

\section{Hauptmenu}
Das Hauptmenu dient dazu um das Basic UI/UX System zu implementieren.
Hier kann der Benutzer dann diverse Einstellungen Tätigen als auch
das gewünschte Level auswählen und starten

\subsection{UI/UX}
Mittels verwendung des UX-Tools-Plug-Ins für Mixed Reality wird
mit bereitgestellten Knöpfen, Oberflächen, Comboboxen, etc...
die Benutzeroberfläche erstellt.

\subsection{Laden der Level}
Durch einen Knopfdruck wird dann in Unreal Engine das der ausgewählte
Level geladen.

\section{Ping Level}
In diesem Level wird das IT-Grundprinzip eines Pings zwischen zweier
PCs dargestellt. Das Kabel zwischen den zwei PCs wird von der
HoloLens getracked und mittels Kurvenberechnung wird dann eine
unsichtbare Kurve über dieses Kabel gezeichnet. Wenn dann der Benutzer
auf die Enter Taste auf einem PC drückt wird ein Ping-Paket simuliert
und auf dieser Kurve von einem PC zu dem anderen geschickt.

\subsection{Object Tracking}
Durch verwendung von bereitgestellten Technologien der HoloLens2
werden die zwei PCs und das Kabel getracked.

\subsection{Kurvenberechnung}
Durch Berechnung der Kurve wird das Kabel als Kurve gespeichert
und dadurch wird es ermöglicht, dass das 3D-Ping-Paket über diese
Kurve von einem PC zum anderen läuft.

\section{Knappsack Problem Level}
In diesem Level wird das IT-Grundprinzip des Knappsack-Problems dargestellt.
Auf einem Tisch wird mittels Spatial Mapping die Oberfläche des Tisches
getracked und dann ein Spatial Anchor platziert. Auf diesem Anchor wird
anschließend der Inventar-Actor platziert. Außerdem liegen auf dem Tisch
verteilt reale Gegenstände die mit einem QR-Code versehen sind. Nimmt der
Spieler einen Gegenstand in die Hand, wird der QR-Code von der HoloLens2
erfasst. Darauf folgend wird der Inhalt des QR-Codes geladen und in einem
Fenster angezeigt. Der Benutzer kann die Gegenstände frei in das Inventar
verteilen und pro neuen Gegenstand wird ein Inventar-Value berechnet.
Wenn der Benutzer mit seiner Lösung zufrieden ist, kann er anschließend
durch einen Kopfdruck die perfekte Lösung in einem zweiten Inventar anzeigen
lassen.

\subsection{Spatial Anchors / ARPins}
Spatial Anchors / ARPins werden verwendet um einen Anchor in der Realen und
Augmented Reality Welt zu setzen. Rund um diesen gesetzten Anchor wird dann die
AR-Welt aufgebaut.
%Genauere Beschreibung + wenn Vorhanden Code von erstellen und löschen von
%Spatial Anchors hinzufügen

\subsection{Spatial Mapping}
Spatial Mapping mapped mittels Sensoren und Kameras die Umgebung in einem
eingestellten Radius rund um den Benutzer. Durch Einstellungen wird spezifiziert
wie genau und hochwertig dieses erstellte Mesh sein soll. In Kombination mit
Spatial Anchors kann dann ermittelt werden falls ein Anchor mit dem Mesh kollidiert
und wenn das der Fall ist kann richtig ermittelt ob das eine richtige Oberfläche ist.
%Genauer Beschreibung + wenn vorhanden Code und Blueprints von Spatial Mapping hinzufügen

\subsection{QR-Code Tagging}
Generierte QR-Codes werden auf die realen Objekte geklebt. In diesen QR-Codes werden
wichtige Informationen zu den Objekten gespeichert. Darunten sind folgende Elemente:
Gewicht, Wert und eine kurze Beschreibung zu diesem Objekt.

\subsection{QR-Code Tracking}
Durch Verwendung der integrierten Kamera rendert die HoloLens2 existente QR-Codes an
der Originalen Positionen in 3D-Objekte. Mittels tracking kann dann auch der Inhalt
der getracked QR-Codes geladen werden.
%Genauer Beschreibung + wenn vorhanden Code und Blueprints von QR-Code-Tracking hinzufügen

\subsection{Knappsack-Algorithmus}
%Hier kommt dann ein Bild von dem Level Blueprint + Custom Code vom Knappsack Algorithmus mit erklärung
Durch Interaktion zwischen echten und 3D-Obejekt können

\subsection{Unit-Tests}
Durch Hilfe von Unit-Tests wird versichert, dass der implementierte Knappsack-Algorithmus
richtig und performant funktioniert.
%Genauere Erklärung + Custom Code der UnitTests

\section{Performance}
Performance-Messung
%Genauere Erklärung

%\subsection{Performance Optimierungen} OPTIONALES THEMA


%Quellen zu den Fragenbögen Dingen finden und ALLES genauer beschreiben

%Quellen zu UnrealEngine Dingen finden und alles GENAUER beschreiben